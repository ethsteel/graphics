#!/usr/bin/env -S uv run --script
#
# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "matplotlib>=3.8.0",
#     "pandas>=2.1.0", 
#     "numpy>=1.24.0"
# ]
# ///
"""
Generate EEST Release Timeline Visualization

This script generates release timeline plots from previously fetched data.
Run fetch_release_data.py first to get the latest data from GitHub.

Usage:
    ./generate_plots.py [--light]

Options:
    --light    Use light theme instead of dark theme (default: dark)

Requirements:
    - releases.txt file (generated by fetch_release_data.py)

Output:
    - eest_releases_timeline_dark.png / eest_releases_timeline_light.png: Standard resolution plot
    - eest_releases_timeline_dark_hires.png / eest_releases_timeline_light_hires.png: High resolution plot
"""

import sys
import argparse
from pathlib import Path
from datetime import datetime, timezone
import matplotlib
matplotlib.use("Agg")  # Non-interactive backend for saving files
import matplotlib.dates as mdates
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from collections import OrderedDict

def check_data_file():
    """Check if release data file exists."""
    script_dir = Path(__file__).parent
    releases_file = script_dir / "build" / "releases.txt"
    if not releases_file.exists():
        print(f"Error: {releases_file} not found!")
        print("Please run 'uv run release_timeline/fetch_release_data.py' first to fetch release data.")
        sys.exit(1)
    return releases_file

def parse_release_data(releases_file):
    """Parse release data into DataFrame."""
    data = []
    
    with open(releases_file, "r") as f:
        for line in f:
            parts = line.strip().split("|")
            if len(parts) >= 3:
                tag = parts[0]
                date_str = parts[1]
                name = parts[2]
                
                # Parse date
                date = datetime.fromisoformat(date_str.replace("Z", "+00:00"))
                
                # Categorize release
                if "@" in tag:
                    prefix = tag.split("@")[0]
                    version = tag.split("@")[1]
                else:
                    prefix = "stable"
                    version = tag
                
                data.append({
                    "tag": tag, 
                    "date": date, 
                    "name": name, 
                    "prefix": prefix, 
                    "version": version
                })
    
    # Add forward-looking stable release (projected)
    forward_release = {
        "tag": "v5.0.0", 
        "date": datetime(2025, 8, 22, 12, 0, 0, tzinfo=timezone.utc), 
        "name": "v5.0.0 (Projected)", 
        "prefix": "stable", 
        "version": "v5.0.0"
    }
    data.append(forward_release)
    
    # Create DataFrame
    df = pd.DataFrame(data)
    df["date"] = pd.to_datetime(df["date"])
    df = df.sort_values("date")
    
    print(f"Parsed {len(df)} total releases (including projected)")
    return df

def get_theme_config(dark_mode=True):
    """Get theme configuration for light or dark mode."""
    if dark_mode:
        return {
            "style": "dark_background",
            "bg_color": "#0a0a0a",
            "legend_bg": "#1a1a1a",
            "text_color": "white",
            "edge_color": "white",
            "categories": OrderedDict([
                ("stable", {"color": "#00ff00", "label": "Full Releases", "marker": "o", "zorder": 5}),
                ("pectra-devnet", {"color": "#ff00ff", "label": "Pectra Devnet", "marker": "s", "zorder": 4}),
                ("fusaka-devnet", {"color": "#00ffff", "label": "Fusaka Devnet", "marker": "^", "zorder": 4}),
                ("eip7692", {"color": "#ff8800", "label": "EIP-7692 (EOF, Cancun)", "marker": "p", "zorder": 3}),
                ("eip7692-prague", {"color": "#ff8800", "label": "EIP-7692 (EOF, Prague)", "marker": "P", "zorder": 3}),
                ("verkle", {"color": "#8800ff", "label": "EIP-6800 (Verkle)", "marker": "h", "zorder": 3}),
                ("benchmark", {"color": "#ff0088", "label": "Benchmark", "marker": "*", "zorder": 3}),
                ("devnet-1", {"color": "#ffff00", "label": "Devnet-1", "marker": "d", "zorder": 4}),
                ("zkevm", {"color": "#ff0088", "label": "zkEVM/Benchmark", "marker": "v", "zorder": 3}),
                ("eip6800", {"color": "#8800ff", "label": "EIP-6800 (Verkle)", "marker": "x", "zorder": 3}),
            ])
        }
    else:
        return {
            "style": "seaborn-v0_8-whitegrid",
            "bg_color": "white",
            "legend_bg": "white", 
            "text_color": "black",
            "edge_color": "black",
            "categories": OrderedDict([
                ("stable", {"color": "#006600", "label": "Full Releases", "marker": "o", "zorder": 5}),
                ("pectra-devnet", {"color": "#cc00cc", "label": "Pectra Devnet", "marker": "s", "zorder": 4}),
                ("fusaka-devnet", {"color": "#0088aa", "label": "Fusaka Devnet", "marker": "^", "zorder": 4}),
                ("eip7692", {"color": "#cc6600", "label": "EIP-7692 (EOF, Cancun)", "marker": "p", "zorder": 3}),
                ("eip7692-prague", {"color": "#cc6600", "label": "EIP-7692 (EOF, Prague)", "marker": "P", "zorder": 3}),
                ("verkle", {"color": "#6600cc", "label": "EIP-6800 (Verkle)", "marker": "h", "zorder": 3}),
                ("benchmark", {"color": "#cc0066", "label": "Benchmark", "marker": "*", "zorder": 3}),
                ("devnet-1", {"color": "#cccc00", "label": "Devnet-1", "marker": "d", "zorder": 4}),
                ("zkevm", {"color": "#cc0066", "label": "zkEVM/Benchmark", "marker": "v", "zorder": 3}),
                ("eip6800", {"color": "#6600cc", "label": "EIP-6800 (Verkle)", "marker": "x", "zorder": 3}),
            ])
        }

def create_visualization(df, dark_mode=True):
    """Create the release timeline visualization."""
    print(f"Creating visualization in {'dark' if dark_mode else 'light'} mode...")
    
    # Get theme configuration
    theme = get_theme_config(dark_mode)
    categories = theme["categories"]
    
    # Group by prefix
    grouped = {}
    for prefix in categories.keys():
        if prefix == "stable":
            mask = ~df["tag"].str.contains("@")
        elif prefix == "pectra-devnet":
            mask = df["prefix"].str.startswith("pectra-devnet") | (df["prefix"] == "devnet-1")
        elif prefix == "fusaka-devnet":
            mask = df["prefix"].str.startswith("fusaka-devnet")
        elif prefix == "devnet-1":
            # Skip devnet-1 as it's combined with pectra-devnet
            continue
        elif prefix == "verkle":
            # Combine verkle and eip6800 as they're both Verkle (EIP-6800)
            mask = (df["prefix"] == "verkle") | (df["prefix"] == "eip6800")
        elif prefix == "benchmark":
            # Combine zkevm and benchmark (zkevm was renamed to benchmark)
            mask = (df["prefix"] == "benchmark") | (df["prefix"] == "zkevm")
        elif prefix == "zkevm":
            # Skip zkevm as it's combined with benchmark
            continue
        elif prefix == "eip6800":
            # Skip eip6800 as it's combined with verkle
            continue
        else:
            mask = df["prefix"] == prefix
        
        if mask.any():
            grouped[prefix] = df[mask].copy().sort_values("date")
            # Add cumulative count for y-axis
            grouped[prefix]["cumulative"] = range(1, len(grouped[prefix]) + 1)
    
    # Create the plot
    plt.style.use(theme["style"])
    fig, ax = plt.subplots(figsize=(16, 10), dpi=100)
    
    # Plot each category
    for prefix, data in grouped.items():
        if prefix in categories:
            cat = categories[prefix]
            
            # Plot line with markers
            ax.plot(
                data["date"],
                data["cumulative"],
                color=cat["color"],
                marker=cat["marker"],
                markersize=8,
                markeredgecolor=theme["edge_color"],
                markeredgewidth=0.5,
                linestyle="--",
                linewidth=1.5,
                alpha=0.8,
                label=f"{cat['label']} ({len(data)} releases)",
                zorder=cat["zorder"],
            )
            
            # Add version labels for selected points
            n_labels = min(6, len(data))  # Maximum 6 labels per category to reduce clutter
            if n_labels > 0:
                if len(data) == 1:
                    indices = [0]
                elif len(data) == 2:
                    indices = [0, 1] 
                else:
                    # Show first, last, and some intermediate points
                    indices = [0, len(data) - 1]  # Always show first and last
                    if n_labels > 2:
                        # Add evenly spaced intermediate points
                        intermediate = np.linspace(1, len(data) - 2, n_labels - 2, dtype=int)
                        indices.extend(intermediate)
                    indices = sorted(set(indices))
                
                for idx in indices:
                    row = data.iloc[idx]
                    # Simplify version display
                    version_text = row["version"].replace("v", "")
                    if "@" in row["tag"]:
                        tag_parts = row["tag"].split("@")
                        prefix_part = tag_parts[0]
                        version_part = tag_parts[1].replace("v", "")
                        
                        # For devnet releases, show devnet-number@version
                        if "devnet" in prefix_part:
                            # Extract devnet number/name after the last dash
                            if "-" in prefix_part:
                                devnet_id = prefix_part.split("-")[-1]
                                version_text = f"{devnet_id}@{version_part}"
                            else:
                                version_text = version_part
                        else:
                            version_text = version_part
                    
                    # Add small offset to avoid overlapping
                    offset_y = 0.2 * (idx % 3 - 1)
                    
                    ax.annotate(
                        version_text,
                        xy=(row["date"], row["cumulative"]),
                        xytext=(5, 5 + offset_y * 10),
                        textcoords="offset points",
                        fontsize=14,
                        color=cat["color"],
                        alpha=0.9,
                        ha="left",
                    )
    
    # Formatting with larger fonts for slide visibility
    ax.set_xlabel("Release Date", fontsize=22, fontweight="bold")
    ax.set_ylabel("Cumulative Number of Releases", fontsize=22, fontweight="bold")
    ax.set_title("Ethereum Execution Spec Tests Vector Releases", fontsize=24, fontweight="bold", pad=20)
    
    # Date formatting on x-axis with larger labels
    ax.xaxis.set_major_formatter(mdates.DateFormatter("%b %Y"))
    ax.xaxis.set_major_locator(mdates.MonthLocator(interval=3))
    plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha="right", fontsize=18)
    ax.tick_params(axis="y", labelsize=16)
    
    # Grid
    ax.grid(True, linestyle=":", alpha=0.3)
    ax.set_axisbelow(True)
    
    # Legend with larger font
    legend = ax.legend(
        loc="upper left", frameon=True, fancybox=True, framealpha=0.9, edgecolor=theme["edge_color"], fontsize=18
    )
    legend.get_frame().set_facecolor(theme["legend_bg"])
    
    # Add total releases count - positioned at Nov 2023, y=5
    total_releases = len(df)
    ax.text(
        datetime(2023, 11, 1, tzinfo=timezone.utc),
        5,
        f"Total: {total_releases} releases",
        fontsize=20,
        ha="center",
        va="center",
        bbox=dict(boxstyle="round", facecolor=theme["legend_bg"], edgecolor=theme["edge_color"], alpha=0.8),
    )
    
    # Adjust layout
    plt.tight_layout()
    
    # Create build directory if it doesn't exist
    script_dir = Path(__file__).parent
    build_dir = script_dir / "build"
    build_dir.mkdir(exist_ok=True)
    
    # Save the plots
    mode_suffix = "_dark" if dark_mode else "_light"
    output_file = build_dir / f"eest_releases_timeline{mode_suffix}.png"
    plt.savefig(output_file, dpi=150, facecolor=theme["bg_color"], edgecolor="none", bbox_inches="tight")
    print(f"Plot saved to: {output_file}")
    
    # Also save a high-res version for presentations
    output_file_hires = build_dir / f"eest_releases_timeline{mode_suffix}_hires.png"
    plt.savefig(output_file_hires, dpi=300, facecolor=theme["bg_color"], edgecolor="none", bbox_inches="tight")
    print(f"High-res plot saved to: {output_file_hires}")
    
    plt.close()
    
    return output_file, output_file_hires

def main():
    """Main execution function."""
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Generate EEST Release Timeline Visualization")
    parser.add_argument("--light", action="store_true", help="Use light theme instead of dark theme")
    args = parser.parse_args()
    
    dark_mode = not args.light
    theme_name = "dark" if dark_mode else "light"
    
    print("=== EEST Release Timeline Plot Generator ===")
    print(f"Using {theme_name} theme")
    print()
    
    # Step 1: Check if data file exists
    releases_file = check_data_file()
    print(f"Using release data from: {releases_file}")
    
    # Step 2: Parse data into DataFrame
    df = parse_release_data(releases_file)
    
    # Step 3: Create visualization
    plot_file, plot_file_hires = create_visualization(df, dark_mode)
    
    # Summary
    print()
    print("=== Plot Generation Complete ===")
    print(f"Files created:")
    print(f"  - {plot_file}")
    print(f"  - {plot_file_hires}")
    print()
    print(f"Total releases visualized: {len(df)}")
    print("Ready for presentation!")

if __name__ == "__main__":
    main()